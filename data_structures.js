// Stacks and Queues

  // stacks -> dpeth first searches
  // RPN (Reverse Polish Notation uses stacks)
  // puhs nums into stack, if NaN, pop out prev

// Hashmaps

  // set just stores values 
  // hash map stores values associated with keys can be null
  // hash table ??
  // ammortized - O(n) only somtimes O(1) most of the time ( O(n) every > n times )  -- hash map (O(n) unless on average more than n)

// Linked Lists - degenerated trees (degraded binary tree)

  // singly linked lists - only one node for each node pointing at the next node
  // first node is the head (nothing is pointing at it)
  // always use a dummy head node (dummy head points to head node) then return dummy head.next (which is your head);
  // fast pointer or advanced pointer (an extra pointer pointing ahead) ??

// Binary Trees

  // inorder: left, root, right
  // preorder: root, left, right
  // postorder: left, right, root

// Heaps

  // complete binary tree does not have nulls in their array representation (always going from left to right starting from the node down each level)
  // heap operations - insert and pop
  
// BST

  // use 10 - ... - 70 tree starting at root of 40 (good start as an example)
  // Look at trees_p1.js and trees_p2.js


// Searching & Sorting

  // QSort, MergeSort, and BSearch (know these well)
  // 


// Dynamic Programming & Memoization

// Select Methodologies

  
// Not covered: Arrays and Strings, Graphs (Breadths First Search most of the time), Tries (a tree with any number of nodes)